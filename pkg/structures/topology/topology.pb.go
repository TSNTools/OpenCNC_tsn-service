// Generated with: protoc --go_out=. --go_opt=paths=source_relative ./pkg/structures/topology/topology.proto

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.32.0--rc1
// source: topology.proto

package topology

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type NodeRole int32

const (
	NodeRole_UNKNOWN             NodeRole = 0
	NodeRole_END_STATION         NodeRole = 1
	NodeRole_BRIDGE              NodeRole = 2
	NodeRole_BRIDGED_END_STATION NodeRole = 3
)

// Enum value maps for NodeRole.
var (
	NodeRole_name = map[int32]string{
		0: "UNKNOWN",
		1: "END_STATION",
		2: "BRIDGE",
		3: "BRIDGED_END_STATION",
	}
	NodeRole_value = map[string]int32{
		"UNKNOWN":             0,
		"END_STATION":         1,
		"BRIDGE":              2,
		"BRIDGED_END_STATION": 3,
	}
)

func (x NodeRole) Enum() *NodeRole {
	p := new(NodeRole)
	*p = x
	return p
}

func (x NodeRole) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeRole) Descriptor() protoreflect.EnumDescriptor {
	return file_topology_proto_enumTypes[0].Descriptor()
}

func (NodeRole) Type() protoreflect.EnumType {
	return &file_topology_proto_enumTypes[0]
}

func (x NodeRole) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeRole.Descriptor instead.
func (NodeRole) EnumDescriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{0}
}

type ManagementProtocol int32

const (
	ManagementProtocol_UNRECOGNIZED ManagementProtocol = 0
	ManagementProtocol_NETCONF      ManagementProtocol = 1
	ManagementProtocol_SNMP         ManagementProtocol = 2 // Extendable for RESTCONF, gNMI, etc.
)

// Enum value maps for ManagementProtocol.
var (
	ManagementProtocol_name = map[int32]string{
		0: "UNRECOGNIZED",
		1: "NETCONF",
		2: "SNMP",
	}
	ManagementProtocol_value = map[string]int32{
		"UNRECOGNIZED": 0,
		"NETCONF":      1,
		"SNMP":         2,
	}
)

func (x ManagementProtocol) Enum() *ManagementProtocol {
	p := new(ManagementProtocol)
	*p = x
	return p
}

func (x ManagementProtocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ManagementProtocol) Descriptor() protoreflect.EnumDescriptor {
	return file_topology_proto_enumTypes[1].Descriptor()
}

func (ManagementProtocol) Type() protoreflect.EnumType {
	return &file_topology_proto_enumTypes[1]
}

func (x ManagementProtocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ManagementProtocol.Descriptor instead.
func (ManagementProtocol) EnumDescriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{1}
}

type DuplexMode int32

const (
	DuplexMode_HD DuplexMode = 0 // Half Duplex
	DuplexMode_FD DuplexMode = 1 // Full Duplex
)

// Enum value maps for DuplexMode.
var (
	DuplexMode_name = map[int32]string{
		0: "HD",
		1: "FD",
	}
	DuplexMode_value = map[string]int32{
		"HD": 0,
		"FD": 1,
	}
)

func (x DuplexMode) Enum() *DuplexMode {
	p := new(DuplexMode)
	*p = x
	return p
}

func (x DuplexMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DuplexMode) Descriptor() protoreflect.EnumDescriptor {
	return file_topology_proto_enumTypes[2].Descriptor()
}

func (DuplexMode) Type() protoreflect.EnumType {
	return &file_topology_proto_enumTypes[2]
}

func (x DuplexMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DuplexMode.Descriptor instead.
func (DuplexMode) EnumDescriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{2}
}

type Topology struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         []*Node                `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Links         []*Link                `protobuf:"bytes,2,rep,name=links,proto3" json:"links,omitempty"`
	Version       *int32                 `protobuf:"varint,3,opt,name=version,proto3,oneof" json:"version,omitempty"` // Optional topology version/revision
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Topology) Reset() {
	*x = Topology{}
	mi := &file_topology_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Topology) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Topology) ProtoMessage() {}

func (x *Topology) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Topology.ProtoReflect.Descriptor instead.
func (*Topology) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{0}
}

func (x *Topology) GetNodes() []*Node {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *Topology) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Topology) GetVersion() int32 {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return 0
}

// Node: Represents a network device.
// Role may be END_STATION, BRIDGE, or BRIDGED_END_STATION as per IEEE 802.1Q-2022 Clause 3.
type Node struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Name           string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` // Node unique identifier
	Type           NodeRole               `protobuf:"varint,2,opt,name=type,proto3,enum=topology.NodeRole" json:"type,omitempty"`
	Ports          []*Port                `protobuf:"bytes,3,rep,name=ports,proto3" json:"ports,omitempty"`
	DeviceInfo     *DeviceInfo            `protobuf:"bytes,4,opt,name=device_info,json=deviceInfo,proto3" json:"device_info,omitempty"`
	ManagementInfo *ManagementInfo        `protobuf:"bytes,5,opt,name=management_info,json=managementInfo,proto3" json:"management_info,omitempty"`
	InventoryInfo  *InventoryInfo         `protobuf:"bytes,6,opt,name=inventory_info,json=inventoryInfo,proto3" json:"inventory_info,omitempty"`
	Properties     *NodeProperties        `protobuf:"bytes,7,opt,name=properties,proto3" json:"properties,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Node) Reset() {
	*x = Node{}
	mi := &file_topology_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Node) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Node) ProtoMessage() {}

func (x *Node) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Node.ProtoReflect.Descriptor instead.
func (*Node) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{1}
}

func (x *Node) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Node) GetType() NodeRole {
	if x != nil {
		return x.Type
	}
	return NodeRole_UNKNOWN
}

func (x *Node) GetPorts() []*Port {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *Node) GetDeviceInfo() *DeviceInfo {
	if x != nil {
		return x.DeviceInfo
	}
	return nil
}

func (x *Node) GetManagementInfo() *ManagementInfo {
	if x != nil {
		return x.ManagementInfo
	}
	return nil
}

func (x *Node) GetInventoryInfo() *InventoryInfo {
	if x != nil {
		return x.InventoryInfo
	}
	return nil
}

func (x *Node) GetProperties() *NodeProperties {
	if x != nil {
		return x.Properties
	}
	return nil
}

type NodeProperties struct {
	state             protoimpl.MessageState       `protogen:"open.v1"`
	Bridge            *BridgeProperties            `protobuf:"bytes,1,opt,name=bridge,proto3,oneof" json:"bridge,omitempty"`
	EndStation        *EndStationProperties        `protobuf:"bytes,2,opt,name=end_station,json=endStation,proto3,oneof" json:"end_station,omitempty"`
	BridgedEndStation *BridgedEndStationProperties `protobuf:"bytes,3,opt,name=bridged_end_station,json=bridgedEndStation,proto3,oneof" json:"bridged_end_station,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *NodeProperties) Reset() {
	*x = NodeProperties{}
	mi := &file_topology_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeProperties) ProtoMessage() {}

func (x *NodeProperties) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeProperties.ProtoReflect.Descriptor instead.
func (*NodeProperties) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{2}
}

func (x *NodeProperties) GetBridge() *BridgeProperties {
	if x != nil {
		return x.Bridge
	}
	return nil
}

func (x *NodeProperties) GetEndStation() *EndStationProperties {
	if x != nil {
		return x.EndStation
	}
	return nil
}

func (x *NodeProperties) GetBridgedEndStation() *BridgedEndStationProperties {
	if x != nil {
		return x.BridgedEndStation
	}
	return nil
}

// Clause 8.6.1.4: Specifies internal processing delays for bridges
type BridgeProperties struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ProcessingDelayNs int32                  `protobuf:"varint,1,opt,name=processing_delay_ns,json=procDelay,proto3" json:"processing_delay_ns,omitempty"` // Nanoseconds
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BridgeProperties) Reset() {
	*x = BridgeProperties{}
	mi := &file_topology_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BridgeProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BridgeProperties) ProtoMessage() {}

func (x *BridgeProperties) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BridgeProperties.ProtoReflect.Descriptor instead.
func (*BridgeProperties) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{3}
}

func (x *BridgeProperties) GetProcessingDelayNs() int32 {
	if x != nil {
		return x.ProcessingDelayNs
	}
	return 0
}

type EndStationProperties struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ApplicationType string                 `protobuf:"bytes,1,opt,name=application_type,json=applicationType,proto3" json:"application_type,omitempty"` // Informational tag (e.g., "RobotArm")
	Function        string                 `protobuf:"bytes,2,opt,name=function,proto3" json:"function,omitempty"`                                      // Role in the network (e.g., sensor/controller/etc.)
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *EndStationProperties) Reset() {
	*x = EndStationProperties{}
	mi := &file_topology_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndStationProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndStationProperties) ProtoMessage() {}

func (x *EndStationProperties) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndStationProperties.ProtoReflect.Descriptor instead.
func (*EndStationProperties) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{4}
}

func (x *EndStationProperties) GetApplicationType() string {
	if x != nil {
		return x.ApplicationType
	}
	return ""
}

func (x *EndStationProperties) GetFunction() string {
	if x != nil {
		return x.Function
	}
	return ""
}

// Clause 5.3: End stations that forward traffic (not just terminate)
type BridgedEndStationProperties struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ProcessingDelayNs int32                  `protobuf:"varint,1,opt,name=processing_delay_ns,json=procDelay,proto3" json:"processing_delay_ns,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BridgedEndStationProperties) Reset() {
	*x = BridgedEndStationProperties{}
	mi := &file_topology_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BridgedEndStationProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BridgedEndStationProperties) ProtoMessage() {}

func (x *BridgedEndStationProperties) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BridgedEndStationProperties.ProtoReflect.Descriptor instead.
func (*BridgedEndStationProperties) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{5}
}

func (x *BridgedEndStationProperties) GetProcessingDelayNs() int32 {
	if x != nil {
		return x.ProcessingDelayNs
	}
	return 0
}

type DeviceInfo struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	DeviceModel        string                 `protobuf:"bytes,1,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`                      // Model name or code
	SupportedProtocols []string               `protobuf:"bytes,2,rep,name=supported_protocols,json=supportedProtocols,proto3" json:"supported_protocols,omitempty"` // E.g., ["IEEE 802.1Qbv", "IEEE 802.1CB"]
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *DeviceInfo) Reset() {
	*x = DeviceInfo{}
	mi := &file_topology_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeviceInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeviceInfo) ProtoMessage() {}

func (x *DeviceInfo) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeviceInfo.ProtoReflect.Descriptor instead.
func (*DeviceInfo) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{6}
}

func (x *DeviceInfo) GetDeviceModel() string {
	if x != nil {
		return x.DeviceModel
	}
	return ""
}

func (x *DeviceInfo) GetSupportedProtocols() []string {
	if x != nil {
		return x.SupportedProtocols
	}
	return nil
}

// Reflects how the CNC should connect to the node's management plane
type ManagementInfo struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	KeyCertificates []string               `protobuf:"bytes,1,rep,name=key_certificates,json=keyCertificates,proto3" json:"key_certificates,omitempty"`
	IpAddress       string                 `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	ManagementPort  uint32                 `protobuf:"varint,3,opt,name=management_port,json=managementPort,proto3" json:"management_port,omitempty"` // TCP port (e.g., 830 for NETCONF)
	UserName        string                 `protobuf:"bytes,4,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	ManagementVlan  uint32                 `protobuf:"varint,5,opt,name=management_vlan,json=managementVlan,proto3" json:"management_vlan,omitempty"` // VLAN used for management (IEEE 802.1Qcp context)
	Protocol        ManagementProtocol     `protobuf:"varint,6,opt,name=protocol,proto3,enum=topology.ManagementProtocol" json:"protocol,omitempty"`  // NETCONF / SNMP / etc.
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ManagementInfo) Reset() {
	*x = ManagementInfo{}
	mi := &file_topology_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ManagementInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManagementInfo) ProtoMessage() {}

func (x *ManagementInfo) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManagementInfo.ProtoReflect.Descriptor instead.
func (*ManagementInfo) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{7}
}

func (x *ManagementInfo) GetKeyCertificates() []string {
	if x != nil {
		return x.KeyCertificates
	}
	return nil
}

func (x *ManagementInfo) GetIpAddress() string {
	if x != nil {
		return x.IpAddress
	}
	return ""
}

func (x *ManagementInfo) GetManagementPort() uint32 {
	if x != nil {
		return x.ManagementPort
	}
	return 0
}

func (x *ManagementInfo) GetUserName() string {
	if x != nil {
		return x.UserName
	}
	return ""
}

func (x *ManagementInfo) GetManagementVlan() uint32 {
	if x != nil {
		return x.ManagementVlan
	}
	return 0
}

func (x *ManagementInfo) GetProtocol() ManagementProtocol {
	if x != nil {
		return x.Protocol
	}
	return ManagementProtocol_UNRECOGNIZED
}

type InventoryInfo struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	SoftwareVersion string                 `protobuf:"bytes,1,opt,name=software_version,json=softwareVersion,proto3" json:"software_version,omitempty"` // Optional extension: hardware_revision, serial_number, etc.
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *InventoryInfo) Reset() {
	*x = InventoryInfo{}
	mi := &file_topology_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InventoryInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InventoryInfo) ProtoMessage() {}

func (x *InventoryInfo) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InventoryInfo.ProtoReflect.Descriptor instead.
func (*InventoryInfo) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{8}
}

func (x *InventoryInfo) GetSoftwareVersion() string {
	if x != nil {
		return x.SoftwareVersion
	}
	return ""
}

// Port: Logical interface on a node.
// Represents physical or virtual ports. Maps to ifIndex in SNMP/YANG.
type Port struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name            string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description     string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	DeviceModel     string                 `protobuf:"bytes,4,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"` // NIC model
	MacAddress      string                 `protobuf:"bytes,5,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	IpAddress       string                 `protobuf:"bytes,6,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	NumberOfQueues  int32                  `protobuf:"varint,7,opt,name=number_of_queues,json=numberOfQueues,proto3" json:"number_of_queues,omitempty"`
	Manufacturer    string                 `protobuf:"bytes,8,opt,name=manufacturer,proto3" json:"manufacturer,omitempty"`
	SoftwareVersion string                 `protobuf:"bytes,9,opt,name=software_version,json=softwareVersion,proto3" json:"software_version,omitempty"`
	Capabilities    *InterfaceCapabilities `protobuf:"bytes,11,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Port) Reset() {
	*x = Port{}
	mi := &file_topology_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Port) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Port) ProtoMessage() {}

func (x *Port) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Port.ProtoReflect.Descriptor instead.
func (*Port) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{9}
}

func (x *Port) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Port) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Port) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Port) GetDeviceModel() string {
	if x != nil {
		return x.DeviceModel
	}
	return ""
}

func (x *Port) GetMacAddress() string {
	if x != nil {
		return x.MacAddress
	}
	return ""
}

func (x *Port) GetIpAddress() string {
	if x != nil {
		return x.IpAddress
	}
	return ""
}

func (x *Port) GetNumberOfQueues() int32 {
	if x != nil {
		return x.NumberOfQueues
	}
	return 0
}

func (x *Port) GetManufacturer() string {
	if x != nil {
		return x.Manufacturer
	}
	return ""
}

func (x *Port) GetSoftwareVersion() string {
	if x != nil {
		return x.SoftwareVersion
	}
	return ""
}

func (x *Port) GetCapabilities() *InterfaceCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

// InterfaceCapabilities: Per-port capabilities.
// Maps to IEEE 802.1Qcp YANG models and Clause 6.4 / Annex L (managed objects)
type InterfaceCapabilities struct {
	state                       protoimpl.MessageState `protogen:"open.v1"`
	PortSpeed                   int32                  `protobuf:"varint,1,opt,name=port_speed,json=portSpeed,proto3" json:"port_speed,omitempty"`                                     // Current active speed (Mbps)
	AdvertisedSpeeds            []int32                `protobuf:"varint,2,rep,packed,name=advertised_speeds,json=advertisedSpeeds,proto3" json:"advertised_speeds,omitempty"`         // All supported speeds (e.g., [100, 1000, 10000])
	SupportedVlanIds            []uint32               `protobuf:"varint,3,rep,packed,name=supported_vlan_ids,json=supportedVlanIds,proto3" json:"supported_vlan_ids,omitempty"`       // Per IEEE 802.1Q Clause 6.9
	SupportedPcpValues          []uint32               `protobuf:"varint,4,rep,packed,name=supported_pcp_values,json=supportedPcpValues,proto3" json:"supported_pcp_values,omitempty"` // Clause 8.6.6: Priority Code Point (0–7)
	Mode                        DuplexMode             `protobuf:"varint,5,opt,name=mode,proto3,enum=topology.DuplexMode" json:"mode,omitempty"`
	MaximumTransmissionUnit     int32                  `protobuf:"varint,6,opt,name=maximum_transmission_unit,json=maximumTransmissionUnit,proto3" json:"maximum_transmission_unit,omitempty"`                // MTU in bytes
	AutoNegotiationEnabled      bool                   `protobuf:"varint,7,opt,name=auto_negotiation_enabled,json=autoNegotiationEnabled,proto3" json:"auto_negotiation_enabled,omitempty"`                   // IEEE 802.3 Clause 28
	SupportsTimeSync            bool                   `protobuf:"varint,8,opt,name=supports_time_sync,json=supportsTimeSync,proto3" json:"supports_time_sync,omitempty"`                                     // Indicates 802.1AS-2020 support
	SupportsFramePreemption     bool                   `protobuf:"varint,9,opt,name=supports_frame_preemption,json=supportsFramePreemption,proto3" json:"supports_frame_preemption,omitempty"`                // IEEE 802.1Qbu
	SupportsStreamFiltering     bool                   `protobuf:"varint,10,opt,name=supports_stream_filtering,json=supportsStreamFiltering,proto3" json:"supports_stream_filtering,omitempty"`               // IEEE 802.1Qci
	SupportsFrer                bool                   `protobuf:"varint,11,opt,name=supports_frer,json=supportsFrer,proto3" json:"supports_frer,omitempty"`                                                  // IEEE 802.1CB
	SupportsTas                 bool                   `protobuf:"varint,12,opt,name=supports_tas,json=supportsTas,proto3" json:"supports_tas,omitempty"`                                                     // Time-Aware Shaper (IEEE 802.1Qbv)
	SupportsCqf                 bool                   `protobuf:"varint,13,opt,name=supports_cqf,json=supportsCqf,proto3" json:"supports_cqf,omitempty"`                                                     // Cyclic Queuing and Forwarding (802.1Qch)
	SupportsCbs                 bool                   `protobuf:"varint,14,opt,name=supports_cbs,json=supportsCbs,proto3" json:"supports_cbs,omitempty"`                                                     // Credit-Based Shaper (802.1Qav)
	SupportsInterfaceTimeOffset bool                   `protobuf:"varint,15,opt,name=supports_interface_time_offset,json=supportsInterfaceTimeOffset,proto3" json:"supports_interface_time_offset,omitempty"` // Indicates whether this interface supports applying a time offset (in nanoseconds) for Qbv schedule (non standard feature)
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *InterfaceCapabilities) Reset() {
	*x = InterfaceCapabilities{}
	mi := &file_topology_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InterfaceCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InterfaceCapabilities) ProtoMessage() {}

func (x *InterfaceCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InterfaceCapabilities.ProtoReflect.Descriptor instead.
func (*InterfaceCapabilities) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{10}
}

func (x *InterfaceCapabilities) GetPortSpeed() int32 {
	if x != nil {
		return x.PortSpeed
	}
	return 0
}

func (x *InterfaceCapabilities) GetAdvertisedSpeeds() []int32 {
	if x != nil {
		return x.AdvertisedSpeeds
	}
	return nil
}

func (x *InterfaceCapabilities) GetSupportedVlanIds() []uint32 {
	if x != nil {
		return x.SupportedVlanIds
	}
	return nil
}

func (x *InterfaceCapabilities) GetSupportedPcpValues() []uint32 {
	if x != nil {
		return x.SupportedPcpValues
	}
	return nil
}

func (x *InterfaceCapabilities) GetMode() DuplexMode {
	if x != nil {
		return x.Mode
	}
	return DuplexMode_HD
}

func (x *InterfaceCapabilities) GetMaximumTransmissionUnit() int32 {
	if x != nil {
		return x.MaximumTransmissionUnit
	}
	return 0
}

func (x *InterfaceCapabilities) GetAutoNegotiationEnabled() bool {
	if x != nil {
		return x.AutoNegotiationEnabled
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsTimeSync() bool {
	if x != nil {
		return x.SupportsTimeSync
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsFramePreemption() bool {
	if x != nil {
		return x.SupportsFramePreemption
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsStreamFiltering() bool {
	if x != nil {
		return x.SupportsStreamFiltering
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsFrer() bool {
	if x != nil {
		return x.SupportsFrer
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsTas() bool {
	if x != nil {
		return x.SupportsTas
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsCqf() bool {
	if x != nil {
		return x.SupportsCqf
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsCbs() bool {
	if x != nil {
		return x.SupportsCbs
	}
	return false
}

func (x *InterfaceCapabilities) GetSupportsInterfaceTimeOffset() bool {
	if x != nil {
		return x.SupportsInterfaceTimeOffset
	}
	return false
}

// Link: Physical connection between two ports.
// Can be inferred from LLDP or CNC-side discovery.
type Link struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Id                 string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	SourceNode         string                 `protobuf:"bytes,2,opt,name=source_node,json=source,proto3" json:"source_node,omitempty"`
	TargetNode         string                 `protobuf:"bytes,3,opt,name=target_node,json=target,proto3" json:"target_node,omitempty"`
	SourcePort         string                 `protobuf:"bytes,4,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	TargetPort         string                 `protobuf:"bytes,5,opt,name=target_port,json=targetPort,proto3" json:"target_port,omitempty"`
	PropagationDelayNs int64                  `protobuf:"varint,6,opt,name=propagation_delay_ns,json=propagationDelay,proto3" json:"propagation_delay_ns,omitempty"` // In nanoseconds
	Bandwidth          int64                  `protobuf:"varint,7,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`                                             // In bits per second
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Link) Reset() {
	*x = Link{}
	mi := &file_topology_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Link) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Link) ProtoMessage() {}

func (x *Link) ProtoReflect() protoreflect.Message {
	mi := &file_topology_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Link.ProtoReflect.Descriptor instead.
func (*Link) Descriptor() ([]byte, []int) {
	return file_topology_proto_rawDescGZIP(), []int{11}
}

func (x *Link) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Link) GetSourceNode() string {
	if x != nil {
		return x.SourceNode
	}
	return ""
}

func (x *Link) GetTargetNode() string {
	if x != nil {
		return x.TargetNode
	}
	return ""
}

func (x *Link) GetSourcePort() string {
	if x != nil {
		return x.SourcePort
	}
	return ""
}

func (x *Link) GetTargetPort() string {
	if x != nil {
		return x.TargetPort
	}
	return ""
}

func (x *Link) GetPropagationDelayNs() int64 {
	if x != nil {
		return x.PropagationDelayNs
	}
	return 0
}

func (x *Link) GetBandwidth() int64 {
	if x != nil {
		return x.Bandwidth
	}
	return 0
}

var File_topology_proto protoreflect.FileDescriptor

const file_topology_proto_rawDesc = "" +
	"\n" +
	"\x0etopology.proto\x12\btopology\"\x81\x01\n" +
	"\bTopology\x12$\n" +
	"\x05nodes\x18\x01 \x03(\v2\x0e.topology.NodeR\x05nodes\x12$\n" +
	"\x05links\x18\x02 \x03(\v2\x0e.topology.LinkR\x05links\x12\x1d\n" +
	"\aversion\x18\x03 \x01(\x05H\x00R\aversion\x88\x01\x01B\n" +
	"\n" +
	"\b_version\"\xdc\x02\n" +
	"\x04Node\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12&\n" +
	"\x04type\x18\x02 \x01(\x0e2\x12.topology.NodeRoleR\x04type\x12$\n" +
	"\x05ports\x18\x03 \x03(\v2\x0e.topology.PortR\x05ports\x125\n" +
	"\vdevice_info\x18\x04 \x01(\v2\x14.topology.DeviceInfoR\n" +
	"deviceInfo\x12A\n" +
	"\x0fmanagement_info\x18\x05 \x01(\v2\x18.topology.ManagementInfoR\x0emanagementInfo\x12>\n" +
	"\x0einventory_info\x18\x06 \x01(\v2\x17.topology.InventoryInfoR\rinventoryInfo\x128\n" +
	"\n" +
	"properties\x18\a \x01(\v2\x18.topology.NodePropertiesR\n" +
	"properties\"\x9e\x02\n" +
	"\x0eNodeProperties\x127\n" +
	"\x06bridge\x18\x01 \x01(\v2\x1a.topology.BridgePropertiesH\x00R\x06bridge\x88\x01\x01\x12D\n" +
	"\vend_station\x18\x02 \x01(\v2\x1e.topology.EndStationPropertiesH\x01R\n" +
	"endStation\x88\x01\x01\x12Z\n" +
	"\x13bridged_end_station\x18\x03 \x01(\v2%.topology.BridgedEndStationPropertiesH\x02R\x11bridgedEndStation\x88\x01\x01B\t\n" +
	"\a_bridgeB\x0e\n" +
	"\f_end_stationB\x16\n" +
	"\x14_bridged_end_station\":\n" +
	"\x10BridgeProperties\x12&\n" +
	"\x13processing_delay_ns\x18\x01 \x01(\x05R\tprocDelay\"]\n" +
	"\x14EndStationProperties\x12)\n" +
	"\x10application_type\x18\x01 \x01(\tR\x0fapplicationType\x12\x1a\n" +
	"\bfunction\x18\x02 \x01(\tR\bfunction\"E\n" +
	"\x1bBridgedEndStationProperties\x12&\n" +
	"\x13processing_delay_ns\x18\x01 \x01(\x05R\tprocDelay\"`\n" +
	"\n" +
	"DeviceInfo\x12!\n" +
	"\fdevice_model\x18\x01 \x01(\tR\vdeviceModel\x12/\n" +
	"\x13supported_protocols\x18\x02 \x03(\tR\x12supportedProtocols\"\x83\x02\n" +
	"\x0eManagementInfo\x12)\n" +
	"\x10key_certificates\x18\x01 \x03(\tR\x0fkeyCertificates\x12\x1d\n" +
	"\n" +
	"ip_address\x18\x02 \x01(\tR\tipAddress\x12'\n" +
	"\x0fmanagement_port\x18\x03 \x01(\rR\x0emanagementPort\x12\x1b\n" +
	"\tuser_name\x18\x04 \x01(\tR\buserName\x12'\n" +
	"\x0fmanagement_vlan\x18\x05 \x01(\rR\x0emanagementVlan\x128\n" +
	"\bprotocol\x18\x06 \x01(\x0e2\x1c.topology.ManagementProtocolR\bprotocol\":\n" +
	"\rInventoryInfo\x12)\n" +
	"\x10software_version\x18\x01 \x01(\tR\x0fsoftwareVersion\"\xed\x02\n" +
	"\x04Port\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12!\n" +
	"\fdevice_model\x18\x04 \x01(\tR\vdeviceModel\x12\x1f\n" +
	"\vmac_address\x18\x05 \x01(\tR\n" +
	"macAddress\x12\x1d\n" +
	"\n" +
	"ip_address\x18\x06 \x01(\tR\tipAddress\x12(\n" +
	"\x10number_of_queues\x18\a \x01(\x05R\x0enumberOfQueues\x12\"\n" +
	"\fmanufacturer\x18\b \x01(\tR\fmanufacturer\x12)\n" +
	"\x10software_version\x18\t \x01(\tR\x0fsoftwareVersion\x12C\n" +
	"\fcapabilities\x18\v \x01(\v2\x1f.topology.InterfaceCapabilitiesR\fcapabilities\"\xdc\x05\n" +
	"\x15InterfaceCapabilities\x12\x1d\n" +
	"\n" +
	"port_speed\x18\x01 \x01(\x05R\tportSpeed\x12+\n" +
	"\x11advertised_speeds\x18\x02 \x03(\x05R\x10advertisedSpeeds\x12,\n" +
	"\x12supported_vlan_ids\x18\x03 \x03(\rR\x10supportedVlanIds\x120\n" +
	"\x14supported_pcp_values\x18\x04 \x03(\rR\x12supportedPcpValues\x12(\n" +
	"\x04mode\x18\x05 \x01(\x0e2\x14.topology.DuplexModeR\x04mode\x12:\n" +
	"\x19maximum_transmission_unit\x18\x06 \x01(\x05R\x17maximumTransmissionUnit\x128\n" +
	"\x18auto_negotiation_enabled\x18\a \x01(\bR\x16autoNegotiationEnabled\x12,\n" +
	"\x12supports_time_sync\x18\b \x01(\bR\x10supportsTimeSync\x12:\n" +
	"\x19supports_frame_preemption\x18\t \x01(\bR\x17supportsFramePreemption\x12:\n" +
	"\x19supports_stream_filtering\x18\n" +
	" \x01(\bR\x17supportsStreamFiltering\x12#\n" +
	"\rsupports_frer\x18\v \x01(\bR\fsupportsFrer\x12!\n" +
	"\fsupports_tas\x18\f \x01(\bR\vsupportsTas\x12!\n" +
	"\fsupports_cqf\x18\r \x01(\bR\vsupportsCqf\x12!\n" +
	"\fsupports_cbs\x18\x0e \x01(\bR\vsupportsCbs\x12C\n" +
	"\x1esupports_interface_time_offset\x18\x0f \x01(\bR\x1bsupportsInterfaceTimeOffset\"\xe0\x01\n" +
	"\x04Link\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\vsource_node\x18\x02 \x01(\tR\x06source\x12\x1b\n" +
	"\vtarget_node\x18\x03 \x01(\tR\x06target\x12\x1f\n" +
	"\vsource_port\x18\x04 \x01(\tR\n" +
	"sourcePort\x12\x1f\n" +
	"\vtarget_port\x18\x05 \x01(\tR\n" +
	"targetPort\x12.\n" +
	"\x14propagation_delay_ns\x18\x06 \x01(\x03R\x10propagationDelay\x12\x1c\n" +
	"\tbandwidth\x18\a \x01(\x03R\tbandwidth*M\n" +
	"\bNodeRole\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x0f\n" +
	"\vEND_STATION\x10\x01\x12\n" +
	"\n" +
	"\x06BRIDGE\x10\x02\x12\x17\n" +
	"\x13BRIDGED_END_STATION\x10\x03*=\n" +
	"\x12ManagementProtocol\x12\x10\n" +
	"\fUNRECOGNIZED\x10\x00\x12\v\n" +
	"\aNETCONF\x10\x01\x12\b\n" +
	"\x04SNMP\x10\x02*\x1c\n" +
	"\n" +
	"DuplexMode\x12\x06\n" +
	"\x02HD\x10\x00\x12\x06\n" +
	"\x02FD\x10\x01B\vZ\t/topologyb\x06proto3"

var (
	file_topology_proto_rawDescOnce sync.Once
	file_topology_proto_rawDescData []byte
)

func file_topology_proto_rawDescGZIP() []byte {
	file_topology_proto_rawDescOnce.Do(func() {
		file_topology_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_topology_proto_rawDesc), len(file_topology_proto_rawDesc)))
	})
	return file_topology_proto_rawDescData
}

var file_topology_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_topology_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_topology_proto_goTypes = []any{
	(NodeRole)(0),                       // 0: topology.NodeRole
	(ManagementProtocol)(0),             // 1: topology.ManagementProtocol
	(DuplexMode)(0),                     // 2: topology.DuplexMode
	(*Topology)(nil),                    // 3: topology.Topology
	(*Node)(nil),                        // 4: topology.Node
	(*NodeProperties)(nil),              // 5: topology.NodeProperties
	(*BridgeProperties)(nil),            // 6: topology.BridgeProperties
	(*EndStationProperties)(nil),        // 7: topology.EndStationProperties
	(*BridgedEndStationProperties)(nil), // 8: topology.BridgedEndStationProperties
	(*DeviceInfo)(nil),                  // 9: topology.DeviceInfo
	(*ManagementInfo)(nil),              // 10: topology.ManagementInfo
	(*InventoryInfo)(nil),               // 11: topology.InventoryInfo
	(*Port)(nil),                        // 12: topology.Port
	(*InterfaceCapabilities)(nil),       // 13: topology.InterfaceCapabilities
	(*Link)(nil),                        // 14: topology.Link
}
var file_topology_proto_depIdxs = []int32{
	4,  // 0: topology.Topology.nodes:type_name -> topology.Node
	14, // 1: topology.Topology.links:type_name -> topology.Link
	0,  // 2: topology.Node.type:type_name -> topology.NodeRole
	12, // 3: topology.Node.ports:type_name -> topology.Port
	9,  // 4: topology.Node.device_info:type_name -> topology.DeviceInfo
	10, // 5: topology.Node.management_info:type_name -> topology.ManagementInfo
	11, // 6: topology.Node.inventory_info:type_name -> topology.InventoryInfo
	5,  // 7: topology.Node.properties:type_name -> topology.NodeProperties
	6,  // 8: topology.NodeProperties.bridge:type_name -> topology.BridgeProperties
	7,  // 9: topology.NodeProperties.end_station:type_name -> topology.EndStationProperties
	8,  // 10: topology.NodeProperties.bridged_end_station:type_name -> topology.BridgedEndStationProperties
	1,  // 11: topology.ManagementInfo.protocol:type_name -> topology.ManagementProtocol
	13, // 12: topology.Port.capabilities:type_name -> topology.InterfaceCapabilities
	2,  // 13: topology.InterfaceCapabilities.mode:type_name -> topology.DuplexMode
	14, // [14:14] is the sub-list for method output_type
	14, // [14:14] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_topology_proto_init() }
func file_topology_proto_init() {
	if File_topology_proto != nil {
		return
	}
	file_topology_proto_msgTypes[0].OneofWrappers = []any{}
	file_topology_proto_msgTypes[2].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_topology_proto_rawDesc), len(file_topology_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_topology_proto_goTypes,
		DependencyIndexes: file_topology_proto_depIdxs,
		EnumInfos:         file_topology_proto_enumTypes,
		MessageInfos:      file_topology_proto_msgTypes,
	}.Build()
	File_topology_proto = out.File
	file_topology_proto_goTypes = nil
	file_topology_proto_depIdxs = nil
}
